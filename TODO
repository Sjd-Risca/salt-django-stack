TODO

- use common values from zinibu_basic pillar, see zinibu.python.python_test
{% from "zinibu/map.jinja" import project with context %}

- get IP information from grains, ports and other data common to all servers, including passwords, can be defined in pillars
- determine values for nginx webroot, bash script, etc, based on project.name coming from pillar, no need to create pillar data that can be figured out

- copy /etc/nginx/sites-available/django-project and make it template to setup nginx virtual host
- copy /home/vagrant/run-project.sh and make it template to setup gunicorn + upstart + nginx
- figure out how to run collectstatic
- Django project should have its settings ready but docs for salt states should mention the basics, like STATIC_ROOT, and the first version of collectstatic should just run on every webhead, later it can implement rsync to a shared directory (maybe nfs) served by nginx
- get things working up to here with salt and then move to Varnish

- create django project in a git repo and then clone it and start it with dev server and gunicorn
(zinibu_dev) testuser2@django5:~$ django-admin startproject secondsite
(zinibu_dev) testuser2@django5:~$ cd secondsite/
(zinibu_dev) testuser2@django5:~/secondsite$ django-admin.py runserver --pythonpath=`pwd` --settings=secondsite.settings 192.168.33.15:8000

it's equivalent to
(zinibu_dev) testuser2@django5:~/secondsite$ python manage.py runserver 192.168.33.15:8000

I prefer django-admin.py because manage.py is just a wrapper for it

- use basic gunicorn
(zinibu_dev) testuser2@django5:~/secondsite$ gunicorn --bind 192.168.33.15:8000 secondsite.wsgi:application


- Each SLS file within the /srv/pillar/ directory should correspond to the states which it matches. Also, make sure passwords for things like db are in pillar files. See postgresql formula.
- move postgres-related lines from zinibu.python.init to postgres specific states, add include to zinibu.python.init.
- just one map.jinja to start

- 

- Create emtpy Django project and make it run with development server and gunicorn manually and then with upstart, then saltify that and proceed to work on db setup.

- I added gunicorn to INSTALLED_APPS and got deprecated message, see new articles
(zinibu_dev) testuser2@django5:~/secondsite$ django-admin.py run_gunicorn --workers=3 --user=testuser2 --group=testuser2 --bind=192.168.33.15:5:8001 --log-level=debug --log-file=/tmp/django-log --pythonpath=`pwd` --settings=secondsite.settings
/home/testuser2/pyvenvs/zinibu_dev/lib/python3.4/site-packages/django/core/management/base.py:259: RemovedInDjango19Warning: "requires_model_validation" is deprecated in favor of "requires_system_checks".
  RemovedInDjango19Warning)

!!!
!!! WARNING: This command is deprecated.
!!! 
!!!         You should now run your application with the WSGI interface
!!!         installed with your project. Ex.:
!!! 
!!!             gunicorn myproject.wsgi:application
!!! 
!!!         See https://docs.djangoproject.com/en/1.5/howto/deployment/wsgi/gunicorn/
!!!         for more info.
!!!




- I want to run the whole thing with:
sudo salt '*' state.highstate

and to do that I need to check that /srv/salt/top.sls is calling zinibu, which is actually zinibu/init.sls, and this is calling the rest of states so I have to go and check each of those states. I'm already done with a good part of zinibu.python.

- Also, I may need to change /srv/salt/top.sls to point a minion, like 'db' to zinibu.postgresql, and the rest to zinibu (which, as mentioned above, is zinibu.init.sls) to work as webheads. As an example from http://docs.saltstack.com/en/latest/topics/best_practices.html:

base:
  'web*':
    - mysql.client
    - mysql.python
  'db*':
    - mysql.server

- zinibu.python is doing django stuff and that should probably go to zinibu.django

- Check how to run pip upgrades like:
pip install Django --upgrade

- States for deployment, probably named zinibu.deploy, and find best way to indicate if it's development, staging, production (pass via pillar in command line, see README and python states). I think I just need to consider one box as one environment so minions' ids are enough to target the states. This means no more having dev, staging and production all on the same box.

- Keep an example of copying a file that includes some jinja changes and variables from grains and pillars. See zinibu/edit/vim.sls.

- Include multiple SLS files as needed, see zinibu/python/python_test.sls
