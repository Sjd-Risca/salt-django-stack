TODO

- study vcl_hash, acl, vcl_hit, vcl_miss and the rest of varnish vcl
- find a way to use haproxy and varnish to cache calls by non-logged in users
- haproxy and test keepalived manually (not salt at first) for fault tolerance
- nfs or glusterfs for static files
- install redis and change settings to use it
- modifying settings.py in django to connect to db and dbsync/migrate as needed, see django formula for ideas
- install haproxy to have a setup like this: haproxy with ssl termination > varnish > nginx > gunicorn , use haproxy with balance uri to maximize cache hits, so, multiple varnish servers but let's start with one haproxy sending to one varnish that does the load balacing

- logrotate to keep all logs under control (syslog-ng for something else?)
- I may need to change /srv/salt/top.sls to point a minion, like 'db' to zinibu.postgresql, and the rest to zinibu (which, as mentioned above, is zinibu.init.sls) to work as webheads. As an example from http://docs.saltstack.com/en/latest/topics/best_practices.html:
- move postgres-related lines from zinibu.python.init to postgres specific states, add include to zinibu.python.init.

base:
  'web*':
    - mysql.client
    - mysql.python
  'db*':
    - mysql.server


- I want to run the whole thing with:
sudo salt '*' state.highstate

- States for deployment, probably named zinibu.deploy, and find best way to indicate if it's development, staging, production (pass via pillar in command line, see README and python states). I think I just need to consider one box as one environment so minions' ids are enough to target the states. This means no more having dev, staging and production all on the same box.

- upgrade to varnish 4?

- check connections
netstat -ctnup | grep "192.168.1.95"

